#!/usr/bin/env python3
"""
–ì–ª—É–±–æ–∫–∏–π –∞–Ω–∞–ª–∏–∑ –ø–∞–π–ø–ª–∞–π–Ω–∞ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –±–æ—Ç–∞.
–û—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —á–µ—Ä–µ–∑ –≤—Å–µ —ç—Ç–∞–ø—ã: SCANNING -> LEVEL_BUILDING -> SIGNAL_WAIT -> SIZING
"""

import asyncio
import sys
import time
import logging
from pathlib import Path

# –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –ø—É—Ç—å –¥–ª—è –∏–º–ø–æ—Ä—Ç–æ–≤
sys.path.insert(0, str(Path(__file__).parent))

from breakout_bot.core.engine import OptimizedOrchestraEngine
from breakout_bot.core.state_machine import TradingState


# –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class PipelineAnalyzer:
    """–ê–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –ø–∞–π–ø–ª–∞–π–Ω–∞ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –±–æ—Ç–∞."""
    
    def __init__(self, preset_name: str = "breakout_v1"):
        self.preset_name = preset_name
        self.engine = None
        self.checkpoints = {}
        
    async def analyze(self):
        """–ü—Ä–æ–≤–µ—Å—Ç–∏ –≥–ª—É–±–æ–∫–∏–π –∞–Ω–∞–ª–∏–∑ –ø–∞–π–ø–ª–∞–π–Ω–∞."""
        print("\n" + "="*80)
        print("üîç –ì–õ–£–ë–û–ö–ò–ô –ê–ù–ê–õ–ò–ó –ü–ê–ô–ü–õ–ê–ô–ù–ê")
        print("="*80 + "\n")
        
        try:
            # 1. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–≤–∏–∂–∫–∞
            await self._test_engine_initialization()
            
            # 2. –ê–Ω–∞–ª–∏–∑ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
            await self._test_scanning_phase()
            
            # 3. –ê–Ω–∞–ª–∏–∑ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è —É—Ä–æ–≤–Ω–µ–π
            await self._test_level_building_phase()
            
            # 4. –ê–Ω–∞–ª–∏–∑ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∏–≥–Ω–∞–ª–æ–≤
            await self._test_signal_generation_phase()
            
            # 5. –ê–Ω–∞–ª–∏–∑ —Ä–∞–∑–º–µ—Ä–µ–Ω–∏—è
            await self._test_sizing_phase()
            
            # 6. –ò—Ç–æ–≥–æ–≤—ã–π –æ—Ç—á–µ—Ç
            self._print_summary()
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞: {e}", exc_info=True)
            print(f"\n‚ùå –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: {e}\n")
            
        finally:
            if self.engine:
                await self.engine.stop()
                
    async def _test_engine_initialization(self):
        """–¢–µ—Å—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –¥–≤–∏–∂–∫–∞."""
        print("\nüì¶ –®–ê–ì 1: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–≤–∏–∂–∫–∞")
        print("-" * 80)
        
        start_time = time.time()
        try:
            self.engine = OptimizedOrchestraEngine(self.preset_name)
            await self.engine.initialize()
            
            duration = time.time() - start_time
            print(f"‚úÖ –î–≤–∏–∂–æ–∫ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –∑–∞ {duration:.2f}s")
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
            components = {
                "exchange_client": self.engine.exchange_client,
                "scanning_manager": self.engine.scanning_manager,
                "signal_manager": self.engine.signal_manager,
                "risk_manager": self.engine.risk_manager,
                "position_manager": self.engine.position_manager,
                "execution_manager": self.engine.execution_manager,
            }
            
            print("\n–ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –¥–≤–∏–∂–∫–∞:")
            for name, component in components.items():
                status = "‚úÖ" if component is not None else "‚ùå"
                print(f"  {status} {name}: {type(component).__name__ if component else 'None'}")
                
            self.checkpoints['initialization'] = {
                'status': 'success',
                'duration': duration
            }
            
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: {e}")
            self.checkpoints['initialization'] = {
                'status': 'failed',
                'error': str(e)
            }
            raise
            
    async def _test_scanning_phase(self):
        """–¢–µ—Å—Ç —Ñ–∞–∑—ã —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è."""
        print("\n\nüîç –®–ê–ì 2: –§–∞–∑–∞ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è")
        print("-" * 80)
        
        start_time = time.time()
        try:
            # –ó–∞–ø—É—Å—Ç–∏—Ç—å —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —á–µ—Ä–µ–∑ –æ—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä
            print("–ó–∞–ø—É—Å–∫ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è...")
            
            # –ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –Ω–∞ —Å–æ—Å—Ç–æ—è–Ω–∏–µ SCANNING
            await self.engine.state_machine.transition_to(
                TradingState.SCANNING,
                "Manual scan test"
            )
            
            # –ó–∞–ø—É—Å—Ç–∏—Ç—å —Ü–∏–∫–ª —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —Å —Ç–∞–π–º–∞—É—Ç–æ–º
            async with asyncio.timeout(120.0):  # 2 –º–∏–Ω—É—Ç—ã —Ç–∞–π–º–∞—É—Ç
                scan_results = await self.engine.scanning_manager.scan_markets(
                    self.engine.exchange_client,
                    "test_session"
                )
                
            duration = time.time() - start_time
            
            print(f"\n‚úÖ –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ –∑–∞ {duration:.2f}s")
            print(f"   –ù–∞–π–¥–µ–Ω–æ –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤: {len(scan_results)}")
            
            # –ê–Ω–∞–ª–∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
            if scan_results:
                print("\nüìä –¢–æ–ø-5 –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤:")
                for i, result in enumerate(scan_results[:5], 1):
                    print(f"   {i}. {result.symbol}")
                    print(f"      - –û–±—â–∏–π –±–∞–ª–ª: {result.total_score:.3f}")
                    print(f"      - –£—Ä–æ–≤–Ω–µ–π –Ω–∞–π–¥–µ–Ω–æ: {len(result.levels)}")
                    print(f"      - Market data: {'‚úÖ' if result.market_data else '‚ùå'}")
                    
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–Ω–Ω—ã—Ö –ø–µ—Ä–≤–æ–≥–æ –∫–∞–Ω–¥–∏–¥–∞—Ç–∞
                first_result = scan_results[0]
                print(f"\nüî¨ –î–µ—Ç–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ {first_result.symbol}:")
                print(f"   - Candles: {len(first_result.market_data.candles) if first_result.market_data else 0}")
                print(f"   - L2 Depth: {'‚úÖ' if first_result.market_data and first_result.market_data.l2_depth else '‚ùå'}")
                print(f"   - Trade Data: {'‚úÖ' if first_result.market_data and first_result.market_data.trades else '‚ùå'}")
                
            else:
                print("‚ö†Ô∏è  –ö–∞–Ω–¥–∏–¥–∞—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
                
            self.checkpoints['scanning'] = {
                'status': 'success',
                'duration': duration,
                'candidates_found': len(scan_results),
                'scan_results': scan_results
            }
            
        except asyncio.TimeoutError:
            duration = time.time() - start_time
            print(f"\n‚ùå –¢–ê–ô–ú–ê–£–¢ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ—Å–ª–µ {duration:.2f}s")
            print("   –í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:")
            print("   1. –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ —Å–∏–º–≤–æ–ª–æ–≤ –¥–ª—è —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è")
            print("   2. –ú–µ–¥–ª–µ–Ω–Ω—ã–µ API –∑–∞–ø—Ä–æ—Å—ã –∫ –±–∏—Ä–∂–µ")
            print("   3. –ü—Ä–æ–±–ª–µ–º—ã —Å —Å–µ—Ç—å—é")
            
            self.checkpoints['scanning'] = {
                'status': 'timeout',
                'duration': duration
            }
            raise
            
        except Exception as e:
            duration = time.time() - start_time
            print(f"\n‚ùå –û—à–∏–±–∫–∞ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è: {e}")
            self.checkpoints['scanning'] = {
                'status': 'failed',
                'error': str(e),
                'duration': duration
            }
            raise
            
    async def _test_level_building_phase(self):
        """–¢–µ—Å—Ç —Ñ–∞–∑—ã –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è —É—Ä–æ–≤–Ω–µ–π."""
        print("\n\nüìê –®–ê–ì 3: –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ —É—Ä–æ–≤–Ω–µ–π")
        print("-" * 80)
        
        scan_results = self.checkpoints.get('scanning', {}).get('scan_results', [])
        
        if not scan_results:
            print("‚ö†Ô∏è  –ü—Ä–æ–ø—É—Å–∫: –Ω–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è")
            self.checkpoints['level_building'] = {
                'status': 'skipped',
                'reason': 'no_scan_results'
            }
            return
            
        try:
            # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —É—Ä–æ–≤–Ω–∏ –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞—Ö —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
            total_levels = sum(len(sr.levels) for sr in scan_results)
            print(f"‚úÖ –í—Å–µ–≥–æ —É—Ä–æ–≤–Ω–µ–π –Ω–∞–π–¥–µ–Ω–æ: {total_levels}")
            
            if total_levels > 0:
                # –ê–Ω–∞–ª–∏–∑ –∫–∞—á–µ—Å—Ç–≤–∞ —É—Ä–æ–≤–Ω–µ–π
                print("\nüìä –ê–Ω–∞–ª–∏–∑ —É—Ä–æ–≤–Ω–µ–π:")
                for result in scan_results[:3]:
                    if result.levels:
                        print(f"\n   {result.symbol}:")
                        for level in result.levels[:2]:
                            print(f"      - –¶–µ–Ω–∞: ${level.price:.4f}")
                            print(f"        –°–∏–ª–∞: {level.strength:.3f}")
                            print(f"        –¢–∏–ø: {level.level_type}")
                            print(f"        –ö–∞—Å–∞–Ω–∏–π: {level.touches}")
            else:
                print("‚ö†Ô∏è  –£—Ä–æ–≤–Ω–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
                
            self.checkpoints['level_building'] = {
                'status': 'success',
                'total_levels': total_levels
            }
            
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è —É—Ä–æ–≤–Ω–µ–π: {e}")
            self.checkpoints['level_building'] = {
                'status': 'failed',
                'error': str(e)
            }
            raise
            
    async def _test_signal_generation_phase(self):
        """–¢–µ—Å—Ç —Ñ–∞–∑—ã –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∏–≥–Ω–∞–ª–æ–≤."""
        print("\n\n‚ö° –®–ê–ì 4: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤")
        print("-" * 80)
        
        scan_results = self.checkpoints.get('scanning', {}).get('scan_results', [])
        
        if not scan_results:
            print("‚ö†Ô∏è  –ü—Ä–æ–ø—É—Å–∫: –Ω–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è")
            self.checkpoints['signal_generation'] = {
                'status': 'skipped',
                'reason': 'no_scan_results'
            }
            return
            
        start_time = time.time()
        try:
            # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤
            print("–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤ –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è...")
            
            signals = await self.engine.signal_manager.generate_signals_from_scan(
                scan_results,
                "test_session"
            )
            
            duration = time.time() - start_time
            
            print(f"\n‚úÖ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –∑–∞ {duration:.2f}s")
            print(f"   –°–∏–≥–Ω–∞–ª–æ–≤ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ: {len(signals)}")
            
            if signals:
                print("\nüìä –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã:")
                for i, signal in enumerate(signals[:5], 1):
                    print(f"\n   {i}. {signal.symbol} - {signal.side}")
                    print(f"      Entry: ${signal.entry:.4f}")
                    print(f"      Stop Loss: ${signal.sl:.4f}")
                    print(f"      Take Profit: ${signal.tp:.4f}")
                    print(f"      Strategy: {signal.strategy}")
                    print(f"      Confidence: {signal.confidence:.2%}")
            else:
                print("\n‚ö†Ô∏è  –°–∏–≥–Ω–∞–ª—ã –Ω–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã")
                print("   –í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:")
                print("   1. –£—Å–ª–æ–≤–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω—ã")
                print("   2. –û—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω—ã —Ä–∏—Å–∫-–º–µ–Ω–µ–¥–∂–µ—Ä–æ–º")
                print("   3. –ù–µ —Ö–≤–∞—Ç–∞–µ—Ç —Ä—ã–Ω–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö")
                
            self.checkpoints['signal_generation'] = {
                'status': 'success',
                'duration': duration,
                'signals_generated': len(signals),
                'signals': signals
            }
            
        except Exception as e:
            duration = time.time() - start_time
            print(f"\n‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∏–≥–Ω–∞–ª–æ–≤: {e}")
            self.checkpoints['signal_generation'] = {
                'status': 'failed',
                'error': str(e),
                'duration': duration
            }
            raise
            
    async def _test_sizing_phase(self):
        """–¢–µ—Å—Ç —Ñ–∞–∑—ã —Ä–∞–∑–º–µ—Ä–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–π."""
        print("\n\nüí∞ –®–ê–ì 5: –†–∞–∑–º–µ—Ä–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–π")
        print("-" * 80)
        
        signals = self.checkpoints.get('signal_generation', {}).get('signals', [])
        
        if not signals:
            print("‚ö†Ô∏è  –ü—Ä–æ–ø—É—Å–∫: –Ω–µ—Ç —Å–∏–≥–Ω–∞–ª–æ–≤")
            self.checkpoints['sizing'] = {
                'status': 'skipped',
                'reason': 'no_signals'
            }
            return
            
        start_time = time.time()
        try:
            print("–û—Ü–µ–Ω–∫–∞ —Ä–∏—Å–∫–æ–≤ –∏ —Ä–∞–∑–º–µ—Ä–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–π...")
            
            equity = 10000.0  # –¢–µ—Å—Ç–æ–≤—ã–π –∫–∞–ø–∏—Ç–∞–ª
            sized_signals = []
            
            for signal in signals:
                # –ü–æ–ª—É—á–∏—Ç—å market data
                market_data = self.engine.signal_manager.signal_market_data.get(signal.symbol)
                
                if not market_data:
                    print(f"   ‚ö†Ô∏è  {signal.symbol}: –Ω–µ—Ç market data")
                    continue
                    
                # –û—Ü–µ–Ω–∏—Ç—å —Ä–∏—Å–∫
                risk_evaluation = self.engine.risk_manager.evaluate_signal_risk(
                    signal,
                    equity,
                    [],  # –ù–µ—Ç –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ–∑–∏—Ü–∏–π
                    market_data
                )
                
                print(f"\n   {signal.symbol}:")
                print(f"      –û–¥–æ–±—Ä–µ–Ω–æ: {'‚úÖ' if risk_evaluation.get('approved') else '‚ùå'}")
                print(f"      –†–∞–∑–º–µ—Ä: {risk_evaluation.get('position_size', 0):.4f}")
                print(f"      –†–∏—Å–∫: {risk_evaluation.get('risk_amount', 0):.2f} USDT")
                
                if risk_evaluation.get('rejection_reasons'):
                    print(f"      –ü—Ä–∏—á–∏–Ω—ã –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è:")
                    for reason in risk_evaluation['rejection_reasons']:
                        print(f"        - {reason}")
                        
                if risk_evaluation.get('approved'):
                    sized_signals.append(signal)
                    
            duration = time.time() - start_time
            
            print(f"\n‚úÖ –†–∞–∑–º–µ—Ä–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ –∑–∞ {duration:.2f}s")
            print(f"   –û–¥–æ–±—Ä–µ–Ω–æ —Å–∏–≥–Ω–∞–ª–æ–≤: {len(sized_signals)} / {len(signals)}")
            
            self.checkpoints['sizing'] = {
                'status': 'success',
                'duration': duration,
                'signals_approved': len(sized_signals),
                'signals_rejected': len(signals) - len(sized_signals)
            }
            
        except Exception as e:
            duration = time.time() - start_time
            print(f"\n‚ùå –û—à–∏–±–∫–∞ —Ä–∞–∑–º–µ—Ä–µ–Ω–∏—è: {e}")
            self.checkpoints['sizing'] = {
                'status': 'failed',
                'error': str(e),
                'duration': duration
            }
            raise
            
    def _print_summary(self):
        """–í—ã–≤–µ—Å—Ç–∏ –∏—Ç–æ–≥–æ–≤—ã–π –æ—Ç—á–µ—Ç."""
        print("\n\n" + "="*80)
        print("üìã –ò–¢–û–ì–û–í–´–ô –û–¢–ß–ï–¢ –ê–ù–ê–õ–ò–ó–ê –ü–ê–ô–ü–õ–ê–ô–ù–ê")
        print("="*80 + "\n")
        
        total_duration = sum(
            cp.get('duration', 0) 
            for cp in self.checkpoints.values()
        )
        
        print(f"–û–±—â–µ–µ –≤—Ä–µ–º—è: {total_duration:.2f}s\n")
        
        # –°—Ç–∞—Ç—É—Å –∫–∞–∂–¥–æ–π —Ñ–∞–∑—ã
        phases = [
            ('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è', 'initialization'),
            ('–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ', 'scanning'),
            ('–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ —É—Ä–æ–≤–Ω–µ–π', 'level_building'),
            ('–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤', 'signal_generation'),
            ('–†–∞–∑–º–µ—Ä–µ–Ω–∏–µ', 'sizing')
        ]
        
        for phase_name, phase_key in phases:
            checkpoint = self.checkpoints.get(phase_key, {})
            status = checkpoint.get('status', 'not_run')
            
            status_emoji = {
                'success': '‚úÖ',
                'failed': '‚ùå',
                'timeout': '‚è±Ô∏è',
                'skipped': '‚è≠Ô∏è',
                'not_run': '‚ùì'
            }.get(status, '‚ùì')
            
            print(f"{status_emoji} {phase_name}: {status.upper()}")
            
            if status == 'success':
                if 'duration' in checkpoint:
                    print(f"   –í—Ä–µ–º—è: {checkpoint['duration']:.2f}s")
                if 'candidates_found' in checkpoint:
                    print(f"   –ö–∞–Ω–¥–∏–¥–∞—Ç–æ–≤: {checkpoint['candidates_found']}")
                if 'total_levels' in checkpoint:
                    print(f"   –£—Ä–æ–≤–Ω–µ–π: {checkpoint['total_levels']}")
                if 'signals_generated' in checkpoint:
                    print(f"   –°–∏–≥–Ω–∞–ª–æ–≤: {checkpoint['signals_generated']}")
                if 'signals_approved' in checkpoint:
                    print(f"   –û–¥–æ–±—Ä–µ–Ω–æ: {checkpoint['signals_approved']}")
                    
            elif status == 'failed':
                print(f"   –û—à–∏–±–∫–∞: {checkpoint.get('error', 'Unknown')}")
                
            elif status == 'timeout':
                print(f"   –ü—Ä–µ–≤—ã—à–µ–Ω —Ç–∞–π–º–∞—É—Ç –ø–æ—Å–ª–µ {checkpoint.get('duration', 0):.2f}s")
                
            elif status == 'skipped':
                print(f"   –ü—Ä–∏—á–∏–Ω–∞: {checkpoint.get('reason', 'Unknown')}")
                
            print()
            
        # –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –ø—Ä–æ–±–ª–µ–º
        print("\n" + "="*80)
        print("üîß –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê –ü–†–û–ë–õ–ï–ú")
        print("="*80 + "\n")
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞, –≥–¥–µ –∑–∞—Å—Ç—Ä—è–ª –ø–∞–π–ø–ª–∞–π–Ω
        last_success = None
        first_failure = None
        
        for phase_name, phase_key in phases:
            checkpoint = self.checkpoints.get(phase_key, {})
            status = checkpoint.get('status')
            
            if status == 'success':
                last_success = phase_name
            elif status in ['failed', 'timeout'] and first_failure is None:
                first_failure = phase_name
                
        if first_failure:
            print(f"‚ùå –ü–∞–π–ø–ª–∞–π–Ω –æ—Å—Ç–∞–Ω–æ–≤–∏–ª—Å—è –Ω–∞ —ç—Ç–∞–ø–µ: {first_failure}")
        elif last_success:
            print(f"‚úÖ –ü–æ—Å–ª–µ–¥–Ω–∏–π —É—Å–ø–µ—à–Ω—ã–π —ç—Ç–∞–ø: {last_success}")
            
            # –°–ª–µ–¥—É—é—â–∏–π —ç—Ç–∞–ø
            phase_index = next(
                (i for i, (n, _) in enumerate(phases) if n == last_success), 
                -1
            )
            if phase_index >= 0 and phase_index < len(phases) - 1:
                next_phase = phases[phase_index + 1][0]
                print(f"‚è≠Ô∏è  –°–ª–µ–¥—É—é—â–∏–π —ç—Ç–∞–ø: {next_phase}")
                
                next_checkpoint = self.checkpoints.get(phases[phase_index + 1][1], {})
                if next_checkpoint.get('status') == 'skipped':
                    print(f"   –ü—Ä–æ–ø—É—â–µ–Ω –∏–∑-–∑–∞: {next_checkpoint.get('reason', 'Unknown')}")
                    
        print()


async def main():
    """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è."""
    analyzer = PipelineAnalyzer()
    await analyzer.analyze()


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è  –ê–Ω–∞–ª–∏–∑ –ø—Ä–µ—Ä–≤–∞–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
    except Exception as e:
        print(f"\n\n‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
        import traceback
        traceback.print_exc()
